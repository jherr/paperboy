// Generated by CoffeeScript 1.4.0
(function() {
  var highlight, nlpData, nlpIndex, processText, scanForTags,
    _this = this;

  highlight = function(snippet, priority, noun, result, index) {
    var color, fw, p, patterns, patts, _i, _len, _ref;
    if (snippet.length === 0) {
      return '';
    }
    color = 'white';
    switch (priority) {
      case 1:
        color = 'goldenrod';
        break;
      case 2:
        color = 'lawnGreen';
        break;
      case -1:
        color = 'orangeRed';
    }
    patts = [];
    if (result != null) {
      _ref = result['PATTERNS MATCHED'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        p = p.replace(/^\s+/, '');
        p = p.replace(/\s+$/, '');
        patts.push(p);
      }
    }
    patterns = patts.join(', ');
    fw = noun ? "font-weight:bold;text-decoration:underline;" : "";
    return "<span data-index='" + index + "' class='fragment' style='background-color:" + color + ";" + fw + "' title='" + patterns + "'>" + snippet + "</span>";
  };

  nlpIndex = 1;

  nlpData = {};

  processText = function(el) {
    var text;
    text = $(el).text();
    text = text.replace(/^\s+/, '');
    text = text.replace(/\s+$/, '');
    if (!(text.length > 0)) {
      return;
    }
    $(el).css('background-color', 'beige');
    return chrome.extension.sendRequest({
      type: 'nlp',
      text: text
    }, function(data) {
      var current, index, loc, noun, np, npl, out, priority, result, start, states, substr, _i, _j, _k, _l, _len, _len1, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      $(el).css('background-color', 'white');
      if (data[0].result.length > 0) {
        states = [];
        for (loc = _i = 0, _ref = text.length; 0 <= _ref ? _i <= _ref : _i >= _ref; loc = 0 <= _ref ? ++_i : --_i) {
          states.push({
            priority: 0,
            result: null,
            noun: false,
            index: 0
          });
        }
        _ref1 = data[0].result;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          result = _ref1[_j];
          priority = 1;
          switch (result.FOUND) {
            case "advocateObject":
              priority = 2;
              break;
            case "detractObject":
              priority = -1;
          }
          start = text.indexOf(result.SNIPPET);
          if (start !== -1) {
            nlpIndex += 1;
            nlpData[nlpIndex] = result;
            chrome.extension.sendRequest({
              type: 'found',
              index: nlpIndex,
              data: result
            });
            if (result.NOUNPHRASES != null) {
              substr = text.slice(start, start + result.SNIPPET.length);
              _ref2 = result.NOUNPHRASES;
              for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
                np = _ref2[_k];
                npl = substr.indexOf(np);
                if (npl !== -1) {
                  for (loc = _l = _ref3 = start + npl, _ref4 = start + npl + np.length - 1; _ref3 <= _ref4 ? _l <= _ref4 : _l >= _ref4; loc = _ref3 <= _ref4 ? ++_l : --_l) {
                    states[loc].noun = true;
                  }
                }
              }
            }
            for (loc = _m = start, _ref5 = start + result.SNIPPET.length - 1; start <= _ref5 ? _m <= _ref5 : _m >= _ref5; loc = start <= _ref5 ? ++_m : --_m) {
              if (states[loc].priority === 0 || states[loc].priority === 1) {
                states[loc].priority = priority;
                states[loc].result = result;
                states[loc].index = nlpIndex;
              }
            }
          } else {
            console.log("Couldn't find: " + result.SNIPPET);
          }
        }
        current = {
          priority: 0,
          noun: false,
          text: '',
          result: null,
          index: -1
        };
        out = '';
        for (loc = _n = 0, _ref6 = text.length - 1; 0 <= _ref6 ? _n <= _ref6 : _n >= _ref6; loc = 0 <= _ref6 ? ++_n : --_n) {
          priority = states[loc].priority;
          noun = states[loc].noun;
          result = states[loc].result;
          index = states[loc].index;
          if (current.priority !== priority || current.noun !== noun || current.result !== result || current.index !== index) {
            out += highlight(current.text, current.priority, current.noun, current.result, current.index);
            current.text = text[loc];
            current.noun = noun;
            current.result = result;
            current.priority = priority;
            current.index = index;
          } else {
            current.text += text[loc];
          }
        }
        out += highlight(current.text, current.priority, current.noun, current.result, current.index);
        $(el).html(out);
        return $('.fragment', el).click(function(event) {
          index = $(event.target).data('index');
          return chrome.extension.sendRequest({
            type: 'selected',
            text: $(event.target).text(),
            result: index === -1 ? null : nlpData[index]
          });
        });
      }
    });
  };

  scanForTags = function() {
    var el, found, _i, _len, _ref;
    found = false;
    _ref = $('.lia-message-body-content p');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      processText(el);
      found = true;
    }
    if (!found) {
      return window.setTimeout(scanForTags, 100);
    }
  };

  window.setTimeout(scanForTags, 100);

}).call(this);
